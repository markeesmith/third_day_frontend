// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  gallery: (where?: GalleryWhereInput) => Promise<boolean>;
  rank: (where?: RankWhereInput) => Promise<boolean>;
  testimonial: (where?: TestimonialWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  gallery: (where: GalleryWhereUniqueInput) => GalleryNullablePromise;
  galleries: (args?: {
    where?: GalleryWhereInput;
    orderBy?: GalleryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gallery>;
  galleriesConnection: (args?: {
    where?: GalleryWhereInput;
    orderBy?: GalleryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GalleryConnectionPromise;
  rank: (where: RankWhereUniqueInput) => RankNullablePromise;
  ranks: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Rank>;
  ranksConnection: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RankConnectionPromise;
  testimonial: (
    where: TestimonialWhereUniqueInput
  ) => TestimonialNullablePromise;
  testimonials: (args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Testimonial>;
  testimonialsConnection: (args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestimonialConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createGallery: (data: GalleryCreateInput) => GalleryPromise;
  updateGallery: (args: {
    data: GalleryUpdateInput;
    where: GalleryWhereUniqueInput;
  }) => GalleryPromise;
  updateManyGalleries: (args: {
    data: GalleryUpdateManyMutationInput;
    where?: GalleryWhereInput;
  }) => BatchPayloadPromise;
  upsertGallery: (args: {
    where: GalleryWhereUniqueInput;
    create: GalleryCreateInput;
    update: GalleryUpdateInput;
  }) => GalleryPromise;
  deleteGallery: (where: GalleryWhereUniqueInput) => GalleryPromise;
  deleteManyGalleries: (where?: GalleryWhereInput) => BatchPayloadPromise;
  createRank: (data: RankCreateInput) => RankPromise;
  updateRank: (args: {
    data: RankUpdateInput;
    where: RankWhereUniqueInput;
  }) => RankPromise;
  upsertRank: (args: {
    where: RankWhereUniqueInput;
    create: RankCreateInput;
    update: RankUpdateInput;
  }) => RankPromise;
  deleteRank: (where: RankWhereUniqueInput) => RankPromise;
  deleteManyRanks: (where?: RankWhereInput) => BatchPayloadPromise;
  createTestimonial: (data: TestimonialCreateInput) => TestimonialPromise;
  updateTestimonial: (args: {
    data: TestimonialUpdateInput;
    where: TestimonialWhereUniqueInput;
  }) => TestimonialPromise;
  updateManyTestimonials: (args: {
    data: TestimonialUpdateManyMutationInput;
    where?: TestimonialWhereInput;
  }) => BatchPayloadPromise;
  upsertTestimonial: (args: {
    where: TestimonialWhereUniqueInput;
    create: TestimonialCreateInput;
    update: TestimonialUpdateInput;
  }) => TestimonialPromise;
  deleteTestimonial: (where: TestimonialWhereUniqueInput) => TestimonialPromise;
  deleteManyTestimonials: (
    where?: TestimonialWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  gallery: (
    where?: GallerySubscriptionWhereInput
  ) => GallerySubscriptionPayloadSubscription;
  rank: (
    where?: RankSubscriptionWhereInput
  ) => RankSubscriptionPayloadSubscription;
  testimonial: (
    where?: TestimonialSubscriptionWhereInput
  ) => TestimonialSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TestimonialOrderByInput =
  | "TestimonialId_ASC"
  | "TestimonialId_DESC"
  | "body_ASC"
  | "body_DESC"
  | "headline_ASC"
  | "headline_DESC";

export type CustomerOrderByInput =
  | "CustomerId_ASC"
  | "CustomerId_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type RankOrderByInput = "RankId_ASC" | "RankId_DESC";

export type GalleryOrderByInput =
  | "GalleryId_ASC"
  | "GalleryId_DESC"
  | "galleryNumItems_ASC"
  | "galleryNumItems_DESC"
  | "galleryPath_ASC"
  | "galleryPath_DESC"
  | "galleryType_ASC"
  | "galleryType_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CustomerWhereUniqueInput = AtLeastOne<{
  CustomerId: Maybe<Int>;
}>;

export interface TestimonialWhereInput {
  TestimonialId?: Maybe<Int>;
  TestimonialId_not?: Maybe<Int>;
  TestimonialId_in?: Maybe<Int[] | Int>;
  TestimonialId_not_in?: Maybe<Int[] | Int>;
  TestimonialId_lt?: Maybe<Int>;
  TestimonialId_lte?: Maybe<Int>;
  TestimonialId_gt?: Maybe<Int>;
  TestimonialId_gte?: Maybe<Int>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  customerId?: Maybe<CustomerWhereInput>;
  headline?: Maybe<String>;
  headline_not?: Maybe<String>;
  headline_in?: Maybe<String[] | String>;
  headline_not_in?: Maybe<String[] | String>;
  headline_lt?: Maybe<String>;
  headline_lte?: Maybe<String>;
  headline_gt?: Maybe<String>;
  headline_gte?: Maybe<String>;
  headline_contains?: Maybe<String>;
  headline_not_contains?: Maybe<String>;
  headline_starts_with?: Maybe<String>;
  headline_not_starts_with?: Maybe<String>;
  headline_ends_with?: Maybe<String>;
  headline_not_ends_with?: Maybe<String>;
  AND?: Maybe<TestimonialWhereInput[] | TestimonialWhereInput>;
  OR?: Maybe<TestimonialWhereInput[] | TestimonialWhereInput>;
  NOT?: Maybe<TestimonialWhereInput[] | TestimonialWhereInput>;
}

export interface CustomerWhereInput {
  CustomerId?: Maybe<Int>;
  CustomerId_not?: Maybe<Int>;
  CustomerId_in?: Maybe<Int[] | Int>;
  CustomerId_not_in?: Maybe<Int[] | Int>;
  CustomerId_lt?: Maybe<Int>;
  CustomerId_lte?: Maybe<Int>;
  CustomerId_gt?: Maybe<Int>;
  CustomerId_gte?: Maybe<Int>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  testimonials_every?: Maybe<TestimonialWhereInput>;
  testimonials_some?: Maybe<TestimonialWhereInput>;
  testimonials_none?: Maybe<TestimonialWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export type GalleryWhereUniqueInput = AtLeastOne<{
  GalleryId: Maybe<Int>;
}>;

export interface RankWhereInput {
  RankId?: Maybe<Int>;
  RankId_not?: Maybe<Int>;
  RankId_in?: Maybe<Int[] | Int>;
  RankId_not_in?: Maybe<Int[] | Int>;
  RankId_lt?: Maybe<Int>;
  RankId_lte?: Maybe<Int>;
  RankId_gt?: Maybe<Int>;
  RankId_gte?: Maybe<Int>;
  galleryId?: Maybe<GalleryWhereInput>;
  AND?: Maybe<RankWhereInput[] | RankWhereInput>;
  OR?: Maybe<RankWhereInput[] | RankWhereInput>;
  NOT?: Maybe<RankWhereInput[] | RankWhereInput>;
}

export interface GalleryWhereInput {
  GalleryId?: Maybe<Int>;
  GalleryId_not?: Maybe<Int>;
  GalleryId_in?: Maybe<Int[] | Int>;
  GalleryId_not_in?: Maybe<Int[] | Int>;
  GalleryId_lt?: Maybe<Int>;
  GalleryId_lte?: Maybe<Int>;
  GalleryId_gt?: Maybe<Int>;
  GalleryId_gte?: Maybe<Int>;
  galleryNumItems?: Maybe<Int>;
  galleryNumItems_not?: Maybe<Int>;
  galleryNumItems_in?: Maybe<Int[] | Int>;
  galleryNumItems_not_in?: Maybe<Int[] | Int>;
  galleryNumItems_lt?: Maybe<Int>;
  galleryNumItems_lte?: Maybe<Int>;
  galleryNumItems_gt?: Maybe<Int>;
  galleryNumItems_gte?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryPath_not?: Maybe<String>;
  galleryPath_in?: Maybe<String[] | String>;
  galleryPath_not_in?: Maybe<String[] | String>;
  galleryPath_lt?: Maybe<String>;
  galleryPath_lte?: Maybe<String>;
  galleryPath_gt?: Maybe<String>;
  galleryPath_gte?: Maybe<String>;
  galleryPath_contains?: Maybe<String>;
  galleryPath_not_contains?: Maybe<String>;
  galleryPath_starts_with?: Maybe<String>;
  galleryPath_not_starts_with?: Maybe<String>;
  galleryPath_ends_with?: Maybe<String>;
  galleryPath_not_ends_with?: Maybe<String>;
  galleryType?: Maybe<String>;
  galleryType_not?: Maybe<String>;
  galleryType_in?: Maybe<String[] | String>;
  galleryType_not_in?: Maybe<String[] | String>;
  galleryType_lt?: Maybe<String>;
  galleryType_lte?: Maybe<String>;
  galleryType_gt?: Maybe<String>;
  galleryType_gte?: Maybe<String>;
  galleryType_contains?: Maybe<String>;
  galleryType_not_contains?: Maybe<String>;
  galleryType_starts_with?: Maybe<String>;
  galleryType_not_starts_with?: Maybe<String>;
  galleryType_ends_with?: Maybe<String>;
  galleryType_not_ends_with?: Maybe<String>;
  ranks_every?: Maybe<RankWhereInput>;
  ranks_some?: Maybe<RankWhereInput>;
  ranks_none?: Maybe<RankWhereInput>;
  AND?: Maybe<GalleryWhereInput[] | GalleryWhereInput>;
  OR?: Maybe<GalleryWhereInput[] | GalleryWhereInput>;
  NOT?: Maybe<GalleryWhereInput[] | GalleryWhereInput>;
}

export type RankWhereUniqueInput = AtLeastOne<{
  RankId: Maybe<Int>;
}>;

export type TestimonialWhereUniqueInput = AtLeastOne<{
  TestimonialId: Maybe<Int>;
}>;

export interface CustomerCreateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  testimonials?: Maybe<TestimonialCreateManyWithoutCustomerIdInput>;
}

export interface TestimonialCreateManyWithoutCustomerIdInput {
  create?: Maybe<
    | TestimonialCreateWithoutCustomerIdInput[]
    | TestimonialCreateWithoutCustomerIdInput
  >;
  connect?: Maybe<TestimonialWhereUniqueInput[] | TestimonialWhereUniqueInput>;
}

export interface TestimonialCreateWithoutCustomerIdInput {
  body?: Maybe<String>;
  headline?: Maybe<String>;
}

export interface CustomerUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  testimonials?: Maybe<TestimonialUpdateManyWithoutCustomerIdInput>;
}

export interface TestimonialUpdateManyWithoutCustomerIdInput {
  create?: Maybe<
    | TestimonialCreateWithoutCustomerIdInput[]
    | TestimonialCreateWithoutCustomerIdInput
  >;
  delete?: Maybe<TestimonialWhereUniqueInput[] | TestimonialWhereUniqueInput>;
  connect?: Maybe<TestimonialWhereUniqueInput[] | TestimonialWhereUniqueInput>;
  set?: Maybe<TestimonialWhereUniqueInput[] | TestimonialWhereUniqueInput>;
  disconnect?: Maybe<
    TestimonialWhereUniqueInput[] | TestimonialWhereUniqueInput
  >;
  update?: Maybe<
    | TestimonialUpdateWithWhereUniqueWithoutCustomerIdInput[]
    | TestimonialUpdateWithWhereUniqueWithoutCustomerIdInput
  >;
  upsert?: Maybe<
    | TestimonialUpsertWithWhereUniqueWithoutCustomerIdInput[]
    | TestimonialUpsertWithWhereUniqueWithoutCustomerIdInput
  >;
  deleteMany?: Maybe<
    TestimonialScalarWhereInput[] | TestimonialScalarWhereInput
  >;
  updateMany?: Maybe<
    | TestimonialUpdateManyWithWhereNestedInput[]
    | TestimonialUpdateManyWithWhereNestedInput
  >;
}

export interface TestimonialUpdateWithWhereUniqueWithoutCustomerIdInput {
  where: TestimonialWhereUniqueInput;
  data: TestimonialUpdateWithoutCustomerIdDataInput;
}

export interface TestimonialUpdateWithoutCustomerIdDataInput {
  body?: Maybe<String>;
  headline?: Maybe<String>;
}

export interface TestimonialUpsertWithWhereUniqueWithoutCustomerIdInput {
  where: TestimonialWhereUniqueInput;
  update: TestimonialUpdateWithoutCustomerIdDataInput;
  create: TestimonialCreateWithoutCustomerIdInput;
}

export interface TestimonialScalarWhereInput {
  TestimonialId?: Maybe<Int>;
  TestimonialId_not?: Maybe<Int>;
  TestimonialId_in?: Maybe<Int[] | Int>;
  TestimonialId_not_in?: Maybe<Int[] | Int>;
  TestimonialId_lt?: Maybe<Int>;
  TestimonialId_lte?: Maybe<Int>;
  TestimonialId_gt?: Maybe<Int>;
  TestimonialId_gte?: Maybe<Int>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  headline?: Maybe<String>;
  headline_not?: Maybe<String>;
  headline_in?: Maybe<String[] | String>;
  headline_not_in?: Maybe<String[] | String>;
  headline_lt?: Maybe<String>;
  headline_lte?: Maybe<String>;
  headline_gt?: Maybe<String>;
  headline_gte?: Maybe<String>;
  headline_contains?: Maybe<String>;
  headline_not_contains?: Maybe<String>;
  headline_starts_with?: Maybe<String>;
  headline_not_starts_with?: Maybe<String>;
  headline_ends_with?: Maybe<String>;
  headline_not_ends_with?: Maybe<String>;
  AND?: Maybe<TestimonialScalarWhereInput[] | TestimonialScalarWhereInput>;
  OR?: Maybe<TestimonialScalarWhereInput[] | TestimonialScalarWhereInput>;
  NOT?: Maybe<TestimonialScalarWhereInput[] | TestimonialScalarWhereInput>;
}

export interface TestimonialUpdateManyWithWhereNestedInput {
  where: TestimonialScalarWhereInput;
  data: TestimonialUpdateManyDataInput;
}

export interface TestimonialUpdateManyDataInput {
  body?: Maybe<String>;
  headline?: Maybe<String>;
}

export interface CustomerUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface GalleryCreateInput {
  galleryNumItems?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryType?: Maybe<String>;
  ranks?: Maybe<RankCreateManyWithoutGalleryIdInput>;
}

export interface RankCreateManyWithoutGalleryIdInput {
  connect?: Maybe<RankWhereUniqueInput[] | RankWhereUniqueInput>;
}

export interface GalleryUpdateInput {
  galleryNumItems?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryType?: Maybe<String>;
  ranks?: Maybe<RankUpdateManyWithoutGalleryIdInput>;
}

export interface RankUpdateManyWithoutGalleryIdInput {
  delete?: Maybe<RankWhereUniqueInput[] | RankWhereUniqueInput>;
  connect?: Maybe<RankWhereUniqueInput[] | RankWhereUniqueInput>;
  set?: Maybe<RankWhereUniqueInput[] | RankWhereUniqueInput>;
  disconnect?: Maybe<RankWhereUniqueInput[] | RankWhereUniqueInput>;
  deleteMany?: Maybe<RankScalarWhereInput[] | RankScalarWhereInput>;
}

export interface RankScalarWhereInput {
  RankId?: Maybe<Int>;
  RankId_not?: Maybe<Int>;
  RankId_in?: Maybe<Int[] | Int>;
  RankId_not_in?: Maybe<Int[] | Int>;
  RankId_lt?: Maybe<Int>;
  RankId_lte?: Maybe<Int>;
  RankId_gt?: Maybe<Int>;
  RankId_gte?: Maybe<Int>;
  AND?: Maybe<RankScalarWhereInput[] | RankScalarWhereInput>;
  OR?: Maybe<RankScalarWhereInput[] | RankScalarWhereInput>;
  NOT?: Maybe<RankScalarWhereInput[] | RankScalarWhereInput>;
}

export interface GalleryUpdateManyMutationInput {
  galleryNumItems?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryType?: Maybe<String>;
}

export interface RankCreateInput {
  galleryId: GalleryCreateOneWithoutRanksInput;
}

export interface GalleryCreateOneWithoutRanksInput {
  create?: Maybe<GalleryCreateWithoutRanksInput>;
  connect?: Maybe<GalleryWhereUniqueInput>;
}

export interface GalleryCreateWithoutRanksInput {
  galleryNumItems?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryType?: Maybe<String>;
}

export interface RankUpdateInput {
  galleryId?: Maybe<GalleryUpdateOneRequiredWithoutRanksInput>;
}

export interface GalleryUpdateOneRequiredWithoutRanksInput {
  create?: Maybe<GalleryCreateWithoutRanksInput>;
  update?: Maybe<GalleryUpdateWithoutRanksDataInput>;
  upsert?: Maybe<GalleryUpsertWithoutRanksInput>;
  connect?: Maybe<GalleryWhereUniqueInput>;
}

export interface GalleryUpdateWithoutRanksDataInput {
  galleryNumItems?: Maybe<Int>;
  galleryPath?: Maybe<String>;
  galleryType?: Maybe<String>;
}

export interface GalleryUpsertWithoutRanksInput {
  update: GalleryUpdateWithoutRanksDataInput;
  create: GalleryCreateWithoutRanksInput;
}

export interface TestimonialCreateInput {
  body?: Maybe<String>;
  customerId: CustomerCreateOneWithoutTestimonialsInput;
  headline?: Maybe<String>;
}

export interface CustomerCreateOneWithoutTestimonialsInput {
  create?: Maybe<CustomerCreateWithoutTestimonialsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutTestimonialsInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface TestimonialUpdateInput {
  body?: Maybe<String>;
  customerId?: Maybe<CustomerUpdateOneRequiredWithoutTestimonialsInput>;
  headline?: Maybe<String>;
}

export interface CustomerUpdateOneRequiredWithoutTestimonialsInput {
  create?: Maybe<CustomerCreateWithoutTestimonialsInput>;
  update?: Maybe<CustomerUpdateWithoutTestimonialsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutTestimonialsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutTestimonialsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface CustomerUpsertWithoutTestimonialsInput {
  update: CustomerUpdateWithoutTestimonialsDataInput;
  create: CustomerCreateWithoutTestimonialsInput;
}

export interface TestimonialUpdateManyMutationInput {
  body?: Maybe<String>;
  headline?: Maybe<String>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface GallerySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GalleryWhereInput>;
  AND?: Maybe<GallerySubscriptionWhereInput[] | GallerySubscriptionWhereInput>;
  OR?: Maybe<GallerySubscriptionWhereInput[] | GallerySubscriptionWhereInput>;
  NOT?: Maybe<GallerySubscriptionWhereInput[] | GallerySubscriptionWhereInput>;
}

export interface RankSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RankWhereInput>;
  AND?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  OR?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  NOT?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
}

export interface TestimonialSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestimonialWhereInput>;
  AND?: Maybe<
    TestimonialSubscriptionWhereInput[] | TestimonialSubscriptionWhereInput
  >;
  OR?: Maybe<
    TestimonialSubscriptionWhereInput[] | TestimonialSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TestimonialSubscriptionWhereInput[] | TestimonialSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Customer {
  CustomerId: Int;
  firstName?: String;
  lastName?: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  CustomerId: () => Promise<Int>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  testimonials: <T = FragmentableArray<Testimonial>>(args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  CustomerId: () => Promise<AsyncIterator<Int>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  testimonials: <T = Promise<AsyncIterator<TestimonialSubscription>>>(args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  CustomerId: () => Promise<Int>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  testimonials: <T = FragmentableArray<Testimonial>>(args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Testimonial {
  TestimonialId: Int;
  body?: String;
  headline?: String;
}

export interface TestimonialPromise extends Promise<Testimonial>, Fragmentable {
  TestimonialId: () => Promise<Int>;
  body: () => Promise<String>;
  customerId: <T = CustomerPromise>() => T;
  headline: () => Promise<String>;
}

export interface TestimonialSubscription
  extends Promise<AsyncIterator<Testimonial>>,
    Fragmentable {
  TestimonialId: () => Promise<AsyncIterator<Int>>;
  body: () => Promise<AsyncIterator<String>>;
  customerId: <T = CustomerSubscription>() => T;
  headline: () => Promise<AsyncIterator<String>>;
}

export interface TestimonialNullablePromise
  extends Promise<Testimonial | null>,
    Fragmentable {
  TestimonialId: () => Promise<Int>;
  body: () => Promise<String>;
  customerId: <T = CustomerPromise>() => T;
  headline: () => Promise<String>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Gallery {
  GalleryId: Int;
  galleryNumItems?: Int;
  galleryPath?: String;
  galleryType?: String;
}

export interface GalleryPromise extends Promise<Gallery>, Fragmentable {
  GalleryId: () => Promise<Int>;
  galleryNumItems: () => Promise<Int>;
  galleryPath: () => Promise<String>;
  galleryType: () => Promise<String>;
  ranks: <T = FragmentableArray<Rank>>(args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GallerySubscription
  extends Promise<AsyncIterator<Gallery>>,
    Fragmentable {
  GalleryId: () => Promise<AsyncIterator<Int>>;
  galleryNumItems: () => Promise<AsyncIterator<Int>>;
  galleryPath: () => Promise<AsyncIterator<String>>;
  galleryType: () => Promise<AsyncIterator<String>>;
  ranks: <T = Promise<AsyncIterator<RankSubscription>>>(args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GalleryNullablePromise
  extends Promise<Gallery | null>,
    Fragmentable {
  GalleryId: () => Promise<Int>;
  galleryNumItems: () => Promise<Int>;
  galleryPath: () => Promise<String>;
  galleryType: () => Promise<String>;
  ranks: <T = FragmentableArray<Rank>>(args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Rank {
  RankId: Int;
}

export interface RankPromise extends Promise<Rank>, Fragmentable {
  RankId: () => Promise<Int>;
  galleryId: <T = GalleryPromise>() => T;
}

export interface RankSubscription
  extends Promise<AsyncIterator<Rank>>,
    Fragmentable {
  RankId: () => Promise<AsyncIterator<Int>>;
  galleryId: <T = GallerySubscription>() => T;
}

export interface RankNullablePromise
  extends Promise<Rank | null>,
    Fragmentable {
  RankId: () => Promise<Int>;
  galleryId: <T = GalleryPromise>() => T;
}

export interface GalleryConnection {
  pageInfo: PageInfo;
  edges: GalleryEdge[];
}

export interface GalleryConnectionPromise
  extends Promise<GalleryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GalleryEdge>>() => T;
  aggregate: <T = AggregateGalleryPromise>() => T;
}

export interface GalleryConnectionSubscription
  extends Promise<AsyncIterator<GalleryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GalleryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGallerySubscription>() => T;
}

export interface GalleryEdge {
  node: Gallery;
  cursor: String;
}

export interface GalleryEdgePromise extends Promise<GalleryEdge>, Fragmentable {
  node: <T = GalleryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GalleryEdgeSubscription
  extends Promise<AsyncIterator<GalleryEdge>>,
    Fragmentable {
  node: <T = GallerySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGallery {
  count: Int;
}

export interface AggregateGalleryPromise
  extends Promise<AggregateGallery>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGallerySubscription
  extends Promise<AsyncIterator<AggregateGallery>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RankConnection {
  pageInfo: PageInfo;
  edges: RankEdge[];
}

export interface RankConnectionPromise
  extends Promise<RankConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RankEdge>>() => T;
  aggregate: <T = AggregateRankPromise>() => T;
}

export interface RankConnectionSubscription
  extends Promise<AsyncIterator<RankConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RankEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRankSubscription>() => T;
}

export interface RankEdge {
  node: Rank;
  cursor: String;
}

export interface RankEdgePromise extends Promise<RankEdge>, Fragmentable {
  node: <T = RankPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RankEdgeSubscription
  extends Promise<AsyncIterator<RankEdge>>,
    Fragmentable {
  node: <T = RankSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRank {
  count: Int;
}

export interface AggregateRankPromise
  extends Promise<AggregateRank>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRankSubscription
  extends Promise<AsyncIterator<AggregateRank>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestimonialConnection {
  pageInfo: PageInfo;
  edges: TestimonialEdge[];
}

export interface TestimonialConnectionPromise
  extends Promise<TestimonialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestimonialEdge>>() => T;
  aggregate: <T = AggregateTestimonialPromise>() => T;
}

export interface TestimonialConnectionSubscription
  extends Promise<AsyncIterator<TestimonialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestimonialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestimonialSubscription>() => T;
}

export interface TestimonialEdge {
  node: Testimonial;
  cursor: String;
}

export interface TestimonialEdgePromise
  extends Promise<TestimonialEdge>,
    Fragmentable {
  node: <T = TestimonialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestimonialEdgeSubscription
  extends Promise<AsyncIterator<TestimonialEdge>>,
    Fragmentable {
  node: <T = TestimonialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTestimonial {
  count: Int;
}

export interface AggregateTestimonialPromise
  extends Promise<AggregateTestimonial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestimonialSubscription
  extends Promise<AsyncIterator<AggregateTestimonial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  CustomerId: Int;
  firstName?: String;
  lastName?: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  CustomerId: () => Promise<Int>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  CustomerId: () => Promise<AsyncIterator<Int>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface GallerySubscriptionPayload {
  mutation: MutationType;
  node: Gallery;
  updatedFields: String[];
  previousValues: GalleryPreviousValues;
}

export interface GallerySubscriptionPayloadPromise
  extends Promise<GallerySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GalleryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GalleryPreviousValuesPromise>() => T;
}

export interface GallerySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GallerySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GallerySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GalleryPreviousValuesSubscription>() => T;
}

export interface GalleryPreviousValues {
  GalleryId: Int;
  galleryNumItems?: Int;
  galleryPath?: String;
  galleryType?: String;
}

export interface GalleryPreviousValuesPromise
  extends Promise<GalleryPreviousValues>,
    Fragmentable {
  GalleryId: () => Promise<Int>;
  galleryNumItems: () => Promise<Int>;
  galleryPath: () => Promise<String>;
  galleryType: () => Promise<String>;
}

export interface GalleryPreviousValuesSubscription
  extends Promise<AsyncIterator<GalleryPreviousValues>>,
    Fragmentable {
  GalleryId: () => Promise<AsyncIterator<Int>>;
  galleryNumItems: () => Promise<AsyncIterator<Int>>;
  galleryPath: () => Promise<AsyncIterator<String>>;
  galleryType: () => Promise<AsyncIterator<String>>;
}

export interface RankSubscriptionPayload {
  mutation: MutationType;
  node: Rank;
  updatedFields: String[];
  previousValues: RankPreviousValues;
}

export interface RankSubscriptionPayloadPromise
  extends Promise<RankSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RankPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RankPreviousValuesPromise>() => T;
}

export interface RankSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RankSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RankSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RankPreviousValuesSubscription>() => T;
}

export interface RankPreviousValues {
  RankId: Int;
}

export interface RankPreviousValuesPromise
  extends Promise<RankPreviousValues>,
    Fragmentable {
  RankId: () => Promise<Int>;
}

export interface RankPreviousValuesSubscription
  extends Promise<AsyncIterator<RankPreviousValues>>,
    Fragmentable {
  RankId: () => Promise<AsyncIterator<Int>>;
}

export interface TestimonialSubscriptionPayload {
  mutation: MutationType;
  node: Testimonial;
  updatedFields: String[];
  previousValues: TestimonialPreviousValues;
}

export interface TestimonialSubscriptionPayloadPromise
  extends Promise<TestimonialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestimonialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestimonialPreviousValuesPromise>() => T;
}

export interface TestimonialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestimonialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestimonialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestimonialPreviousValuesSubscription>() => T;
}

export interface TestimonialPreviousValues {
  TestimonialId: Int;
  body?: String;
  headline?: String;
}

export interface TestimonialPreviousValuesPromise
  extends Promise<TestimonialPreviousValues>,
    Fragmentable {
  TestimonialId: () => Promise<Int>;
  body: () => Promise<String>;
  headline: () => Promise<String>;
}

export interface TestimonialPreviousValuesSubscription
  extends Promise<AsyncIterator<TestimonialPreviousValues>>,
    Fragmentable {
  TestimonialId: () => Promise<AsyncIterator<Int>>;
  body: () => Promise<AsyncIterator<String>>;
  headline: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Gallery",
    embedded: false
  },
  {
    name: "Rank",
    embedded: false
  },
  {
    name: "Testimonial",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
